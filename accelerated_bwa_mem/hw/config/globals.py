import os

NUM_SMEM_CORES = int(os.getenv("NUM_SMEM_CORES", 8))
IMPLEMENT_FOR_REAL_HBM = os.getenv("IMPLEMENT_FOR_REAL_HBM", "FALSE") == "TRUE"
HBM_ID_WIDTH = int(os.getenv("HBM_ID_WIDTH", 6))
SMEM_KERNEL_PIPELINE_LOG2_DEPTH = int(os.getenv("SMEM_KERNEL_PIPELINE_LOG2_DEPTH", 6))
GLOBAL_ADDRESSING = os.getenv("GLOBAL_ADDRESSING", "FALSE") == "TRUE"
HBM_1ST_LAYER_CROSSBAR = os.getenv("HBM_1ST_LAYER_CROSSBAR", "FALSE") == "TRUE"
HBM_2ND_LAYER_CROSSBAR = os.getenv("HBM_2ND_LAYER_CROSSBAR", "FALSE") == "TRUE"

attributeConditions = [
    (
        not (NUM_SMEM_CORES > 4 and (NUM_SMEM_CORES & 3 != 0)),
        "NUM_SMEM_CORES has to be smaller than 4 or a multiple of 4!",
    ),
    (
        not HBM_1ST_LAYER_CROSSBAR or NUM_SMEM_CORES >= 4,
        "Using the crossbar reqiures at least 4 SMEM Cores!",
    ),
    (
        not GLOBAL_ADDRESSING or IMPLEMENT_FOR_REAL_HBM,
        "URAM does not support global addressing!",
    ),
    (
        SMEM_KERNEL_PIPELINE_LOG2_DEPTH >= 1 and SMEM_KERNEL_PIPELINE_LOG2_DEPTH <= 8,
        "SMEM_KERNEL_PIPELINE_LOG2_DEPTH only supports values between 1 and 7",
    ),
    (
        not HBM_2ND_LAYER_CROSSBAR or HBM_1ST_LAYER_CROSSBAR,
        "Second layer crossbar requires first layer crossbar",
    ),
]

for _, err in filter(lambda condition: not condition[0], attributeConditions):
    print(f"ERROR: {err}")
    raise AttributeError(err)

NUM_HBM_STREAMS = (16 if NUM_SMEM_CORES <= 8 else 32) if HBM_2ND_LAYER_CROSSBAR else NUM_SMEM_CORES

NUM_SMEM_CORES_PER_CORE_GROUP = 4
NUM_SMEM_CORE_GROUPS = math.ceil(NUM_SMEM_CORES / NUM_SMEM_CORES_PER_CORE_GROUP)

HBM_ADDR_SELECTOR_SIZE_BITS = 4 if HBM_2ND_LAYER_CROSSBAR or GLOBAL_ADDRESSING else (2 if HBM_1ST_LAYER_CROSSBAR else 0)    
HBM_BASE_ADDR_SIZE_BITS = 22 if IMPLEMENT_FOR_REAL_HBM else 9

BWT_REQUEST_GLOBAL_ADDR_WIDTH = HBM_BASE_ADDR_SIZE_BITS + HBM_ADDR_SELECTOR_SIZE_BITS
BWT_REQUEST_LOCAL_ADDR_WIDTH = HBM_BASE_ADDR_SIZE_BITS + (4 if GLOBAL_ADDRESSING else 0)

PIPELINE_INDEX_WIDTH = SMEM_KERNEL_PIPELINE_LOG2_DEPTH + 1
BWT_EXTEND_STREAM_ELEMENT_WIDTH = 133 + PIPELINE_INDEX_WIDTH
DEFAULT_STREAM_BUFFER_LOG_DEPTH = 2
HBM_CACHE_LINES_PER_BWT_ENTRY = 2
NUM_TERMINATION_SIGNAL_STREAMS = 3 * NUM_SMEM_CORES + 2


NUM_ACCELERATOR_BWT_INTERVAL_VECTOR_CACHE_LINES_128 = 64
NUM_SMEM_BUFFER_ENTRIES_128 = NUM_ACCELERATOR_BWT_INTERVAL_VECTOR_CACHE_LINES_128 * (
    2 ** SMEM_KERNEL_PIPELINE_LOG2_DEPTH
)
SMEM_BUFFER_ADDR_WIDTH = int(math.log2(NUM_SMEM_BUFFER_ENTRIES_128))
SMEM_BUFFER_DATA_WIDTH = 128

ACCELERATOR_RESULT_BUFFER_NUM_ENTRIES_BITS = 3
ACCELERATOR_RESULT_BUFFER_ADDR_WIDTH = ACCELERATOR_RESULT_BUFFER_NUM_ENTRIES_BITS + int(
    math.log2(NUM_ACCELERATOR_BWT_INTERVAL_VECTOR_CACHE_LINES_128)
)
ACCELERATOR_RESULT_BUFFER_DATA_WIDTH = SMEM_BUFFER_DATA_WIDTH
